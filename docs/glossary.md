
### TOKEN NAMES
In the python parser these tokens are in the `const char *_PyParser_TokenNames[]` object.

`ENDMARKER` :
`NAME` :
`NUMBER` :
`STRING` :
`NEWLINE` :
`INDENT` :
`DEDENT` :
`LPAR` :
`RPAR` :
`LSQB` :
`RSQB` :
`COLON` :
`COMMA` :
`SEMI` :
`PLUS` :
`MINUS` :
`STAR` :
`SLASH` :
`VBAR` :
`AMPER` :
`LESS` :
`GREATER` :
`EQUAL` :
`DOT` :
`PERCENT` :
`LBRACE` :
`RBRACE` :
`EQEQUAL` :
`NOTEQUAL` :
`LESSEQUAL` :
`GREATEREQUAL` :
`TILDE` :
`CIRCUMFLEX` :
`LEFTSHIFT` :
`RIGHTSHIFT` :
`DOUBLESTAR` :
`PLUSEQUAL` :
`MINEQUAL` :
`STAREQUAL` :
`SLASHEQUAL` :
`PERCENTEQUAL` :
`AMPEREQUAL` :
`VBAREQUAL` :
`CIRCUMFLEXEQUAL` :
`LEFTSHIFTEQUAL` :
`RIGHTSHIFTEQUAL` :
`DOUBLESTAREQUAL` :
`DOUBLESLASH` :
`DOUBLESLASHEQUAL` :
`AT` :
`ATEQUAL` :
`RARROW` :
`ELLIPSIS` :

**(This table must match the #defines in token.h!)**

`OP` :
`<ERRORTOKEN>` :
`COMMENT` :
`NL` :
`ENCODING` :
`<N_TOKENS>` :

_Look at the file `cpython/Lib/keyword.py`_

```Keywords (from "cpython/Python/graminit.c")

This file is automatically generated; please don't muck it up!

To update the symbols in this file, `cd` to the top directory of
the python source tree after building the interpreter and run:

    ./python Lib/keyword.py
```

# Keywords

`Keywords` in programming languages are specific words that are reserved to communicate specific things to the computer. These words remain consistent across all uses of the programming language.

### Truth Values
_Truth values_ are the results of comparison operations or logical (Boolean) operations.

`True`: similar to `1`, **TRUE** in boolean logic  
`False`: similar to `0`, **FALSE** in boolean logic  

### None
`None`: special constant in python that represents the absence of a value or null value.

>**NOTE**: It is an object with the datatype `NoneType`. There cannot be multiple `None` objects but can assign it to variables which would be equal to one another. `None` does NOT imply `False`, `0`, or empty list/string/dict.

### Logical Operators
The other logical operators. Each operator has their own truth table:

`and`: will result into `True` only if both the operands are `True`  
`not`: used to invert the truth value  
`or`: will result into `True` if any the operands are `True`  

### Alias
`as`: used to create an alias while importing a module, giving a different name to a module while importing it.

### Debugging
`assert`: used for debugging purposes by checking the internal state or if assumptions are true.

>**NOTE**: If the assert condition is true, nothing will happen. But if the condition is false, the error - `AssertionError` is raised.

### Loops
`for`: used for looping, generally when we know the number of times we want to loop with any type of sequence like a list or string.  

`if`: used for conditional branching or decision making.

`elif`: short for "else if" used for conditional branching or decision making.  

`else`: used for conditional branching or decision making if the condition is false; the last resort.  

To alter the loop's normal behavior, use the following keywords:  
`break`: this will end the smallest loop it is in and control flows to the statement immediately below the loop.  

`continue`: causes to end the current iteration of the loop, but not the whole loop.  

`in`: used to test if a sequence (list, tuple, string, etc.) contains a value. It returns `TRUE` if the value is present. Its secondary use is to traverse through a sequence in a `for` loop.  

`while`: used for looping. The statements inside this type of loop will continue to execute until the condition for the `while` loop evaluates to `FALSE` or a `break` statement is encountered.  

### User Defined Structures
`class`: used to define a new user-defined class - which is a collection of related attributes and methods that try to represent a real world situation.

`def`: used to define a new user-defined function.  

`async`:
`await`:
`del`:

### Exceptions
Exceptions are errors that suggest something went wrong while executing the program. Some examples of errors that one could encounter are `IOError`, `ValueError`, `ZeroDivisionError`, `ImportError`, `NameError`, `TypeError`. To catch exceptions, use `try...except`blocks.  

`except`: used with exceptions, where `try...except` blocks are used to catch exceptions if they fail the `try` set of instructions.  

`try`: used with exceptions, where `try...except` blocks are used to catch exceptions by trying out a set of instructions to see if an exception occur.  

`raise`: to raise an exception explicitly.  

`finally`: used with `try...except` statements to close up resources or file streams. This ensures that the block of code inside it gets executed even if there is an unhandled exception.   


### Module Abstractions

`from`: to import specific attributes or functions into the current namespace, use `from...import`.   

`import`: used to import modules into the current namespace.  

### Variable Declarations
`global`: used to declare that a variable inside the function is global (outside the function).

>**NOTE**: As a global variable, if we need to read the value of the variable we do not need to define it as global. If we need to modify the value of a global variable inside a function, then we must declare it with global, otherwise a local variable is created.  

`lambda`:  used to create an inline, anonymous function (function without a name), without a `return` statement, consisting of an expression that is evaluated and returned.  

`nonlocal`:  used to declare that a variable inside a nested function (function inside a function) is not local to it, meaning it lies in the outer inclosing function. (similar to the `global` keyword).

>**NOTE**: If you need to modify a non-local variable inside a nested function, then we must declare it with `nonlocal`. Otherwise a local variable with that name is created inside the nested function.  

`is`: used for testing object identity, by testing if the two variables refer to the same object. This will return `TRUE` if the objects are identical and `FALSE` if not.  

`pass`: null statement where nothing happens when executed, mainly used as a placeholder.  

`return`: used inside a function to exit and return a value.  

>**NOTE**: If we do not return a value explicitly, `NONE` is returned automatically.  

`with`: statement used to wrap the execution of a block of code within methods defined by the context manager.  

>**NOTE**: "Context Manager" is a class that implements `__enter__` and `__exit__` methods. Use of `with` statement ensures that the `__exit__` method is called at the end of the nested block. Tis concept is similar to the use of `try...finally` block.  

`yield`: used inside a function like a `return` statement, however it returns a generator.  

>**NOTE**: A Generator is an iterator that generates one item at a time. A large list of value will take up a lot of memory. Generators are useful in this situation as it generates only one value at a time instead of storing all the values in memory.  
